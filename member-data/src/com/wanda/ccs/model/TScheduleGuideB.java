package com.wanda.ccs.model;

// Generated 2011-10-20 16:15:19 by Hibernate Tools 3.4.0.CR1

import static javax.persistence.GenerationType.SEQUENCE;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;
import javax.persistence.Transient;

import org.apache.commons.lang.StringUtils;
import org.hibernate.annotations.Cache;
import org.hibernate.annotations.CacheConcurrencyStrategy;

import com.xcesys.extras.core.dao.model.VersionableEntity;
import com.xcesys.extras.util.CommonUtil;

/**
 * TScheduleGuideB generated by hbm2java
 */
@Entity
@Table(name = "T_SCHEDULE_GUIDE_B")
@org.hibernate.annotations.Entity(dynamicUpdate = true, dynamicInsert = true)
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class TScheduleGuideB extends VersionableEntity implements
		java.io.Serializable {

	private static final long serialVersionUID = 5600902020623559191L;
	private Long id;
	private TScheduleGuideH tScheduleGuideH;
	private Long filmId;
	private TFilm tFilm;

	private String exact;// 精确型信息
	private String description;

	// 以下皆未用
	private Long ratio;
	private Long cinemaId;
	private TCinema tCinema;
	private Long minShowNum;// 最少场次数

	public TScheduleGuideB() {
	}

	@SequenceGenerator(name = "generator", sequenceName = "S_T_SCHEDULE_GUIDE_B")
	@Id
	@GeneratedValue(strategy = SEQUENCE, generator = "generator")
	@Column(name = "SEQID", unique = true, nullable = false, precision = 38, scale = 0)
	public Long getId() {
		return this.id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "SCHEDULE_GUIDE_H_ID")
	public TScheduleGuideH gettScheduleGuideH() {
		return this.tScheduleGuideH;
	}

	public void settScheduleGuideH(TScheduleGuideH tScheduleGuideH) {
		this.tScheduleGuideH = tScheduleGuideH;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "FILM_ID", insertable = false, updatable = false)
	@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
	public TFilm gettFilm() {
		return this.tFilm;
	}

	public void settFilm(TFilm tFilm) {
		this.tFilm = tFilm;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "CINEMA_ID", insertable = false, updatable = false)
	@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
	public TCinema gettCinema() {
		return this.tCinema;
	}

	public void settCinema(TCinema tCinema) {
		this.tCinema = tCinema;
	}

	@Column(name = "MIN_SHOW_NUM", precision = 38, scale = 0)
	public Long getMinShowNum() {
		return this.minShowNum;
	}

	public void setMinShowNum(Long minShowNum) {
		this.minShowNum = minShowNum;
	}

	@Column(name = "RATIO", precision = 38, scale = 0)
	public Long getRatio() {
		return this.ratio;
	}

	public void setRatio(Long ratio) {
		this.ratio = ratio;
	}

	@Column(name = "DESCRIPTION", length = 500)
	public String getDescription() {
		return this.description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	@Column(name = "FILM_ID", precision = 38, scale = 0)
	public Long getFilmId() {
		return filmId;
	}

	public void setFilmId(Long filmId) {
		this.filmId = filmId;
	}

	@Column(name = "CINEMA_ID", precision = 38, scale = 0)
	public Long getCinemaId() {
		return cinemaId;
	}

	public void setCinemaId(Long cinemaId) {
		this.cinemaId = cinemaId;
	}

	@Column(name = "EXACT", length = 500)
	public String getExact() {
		return exact;
	}

	public void setExact(String exact) {
		this.exact = exact;
	}

	@Transient
	public Map<String, String> getExactMap() {
		return CommonUtil.splitScheduleGuideExact(this.getExact());
	}
	@Transient
	public Map<Long, String> getExactMap2() {
		Map<Long, String> exactMap2 = null;
		String e = this.getExact();
		if (StringUtils.isNotBlank(e)) {
			exactMap2 = new LinkedHashMap<Long, String>(){
				private static final long serialVersionUID = 1L;
				@Override
				public String get(Object obj) {
					if(isEmpty()){
						return null;
					}
					if(containsKey(obj)){
						return super.get(obj);
					}
					if(obj != null && !"".equals(obj)){
						long in = Long.valueOf(""+obj);
						int size = size();
						Long[] keys = keySet().toArray(new Long[size]);
						long minKey = keys[0];
						long maxKey = keys[keys.length-1];
						if(in>maxKey){
							return super.get(maxKey);
						}
						if(in<minKey){
							return super.get(minKey);
						}
					}
					return null;
				}
			};
			String[] ss = StringUtils.split(e, ',');
			for (String s : ss) {
				String[] ht = StringUtils.split(s, ':');
				if (ht.length == 1) {
					exactMap2.put(Long.parseLong(ht[0]), "");
				} else {
					exactMap2.put(Long.parseLong(ht[0]), ht[1]);
				}
			}
		}
		return exactMap2;
	}

}
