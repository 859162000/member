package com.wanda.ccs.model;

// Generated Dec 5, 2012 10:35:22 AM by Hibernate Tools 3.4.0.CR1

import static javax.persistence.GenerationType.SEQUENCE;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Blob;
import java.util.ArrayList;
import java.util.List;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.OneToMany;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;
import javax.persistence.Transient;

import com.aggrepoint.adk.FileParameter;
import com.xcesys.extras.core.dao.model.VersionableEntity;
import com.xcesys.extras.util.BlobFieldUtil;

/**
 * TConBrand generated by hbm2java
 */
@Entity
@Table(name = "T_FILE_ATTACH")
@org.hibernate.annotations.Entity(dynamicUpdate = true, dynamicInsert = true)
public class TFileAttach extends VersionableEntity implements
		java.io.Serializable {
	
	/**
	 * 
	 */
	private static final long serialVersionUID = -4072977326195325022L;
	private Long id;
	private Long refObjectId;
	private String refObjectType;
	private String fileName;
	private Blob fileData;
	private Long fileSize;
	private String fileDesc;
	private String contentType;
	private String status;//文件状态 入库成功S;数据有误E;等待入库W;模板M;正常文件F
	
	private boolean delete;//标记是否删除
	
	public List<TAbatchErreLog> tAbatchErreLogs = new ArrayList<TAbatchErreLog>();
	
	
	public TFileAttach() {
	}
	public TFileAttach(String refObjectType,String status) {
		this.refObjectType = refObjectType;
		this.status = status;
	}
	
	public void copy(TFileAttach fileAttach) {
		if(fileAttach == null)
			return ;
		this.refObjectType = fileAttach.getRefObjectType();
		this.fileName = fileAttach.getFileName();
		this.fileData = fileAttach.getFileData();
		this.fileSize = fileAttach.getFileSize();
		this.fileDesc = fileAttach.getFileDesc();
		this.contentType = fileAttach.getContentType();
		this.status = fileAttach.getStatus();
	}
	
	
	public TFileAttach(TFileAttach fileAttach) {
		if(fileAttach == null)
			return ;
		this.refObjectType = fileAttach.getRefObjectType();
		this.fileName = fileAttach.getFileName();
		this.fileData = fileAttach.getFileData();
		this.fileSize = fileAttach.getFileSize();
		this.fileDesc = fileAttach.getFileDesc();
		this.contentType = fileAttach.getContentType();
		this.status = fileAttach.getStatus();
	}

	@SequenceGenerator(name = "generator", sequenceName = "S_T_FILE_ATTACH", allocationSize = 1)
	@Id
	@GeneratedValue(strategy = SEQUENCE, generator = "generator")
	@Column(name = "FILE_ATTACH_ID", unique = true, nullable = false, precision = 22, scale = 0)
	public Long getId() {
		return this.id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	
	@Column(name = "REF_OBJECT_ID")
	public Long getRefObjectId() {
		return refObjectId;
	}

	public void setRefObjectId(Long refObjectId) {
		this.refObjectId = refObjectId;
	}

	@Column(name = "REF_OBJECT_TYPE")
	public String getRefObjectType() {
		return refObjectType;
	}

	public void setRefObjectType(String refObjectType) {
		this.refObjectType = refObjectType;
	}
	
	@Column(name = "FILE_NAME")
	public String getFileName() {
		return fileName;
	}

	public void setFileName(String fileName) {
		this.fileName = fileName;
	}

	@Column(name = "FILE_DATA")
	public Blob getFileData() {
		return fileData;
	}

	public void setFileData(Blob fileData) {
		this.fileData = fileData;
	}

	@Column(name = "FILE_SIZE")
	public Long getFileSize() {
		return fileSize;
	}

	public void setFileSize(Long fileSize) {
		this.fileSize = fileSize;
	}
	
	@Column(name = "FILE_DESC")
	public String getFileDesc() {
		return fileDesc;
	}

	public void setFileDesc(String fileDesc) {
		this.fileDesc = fileDesc;
	}

	@Column(name = "CONTENT_TYPE")
	public String getContentType() {
		return contentType;
	}
	public void setContentType(String contentType) {
		this.contentType = contentType;
	}

	@Column(name = "FILE_STATUS")
	public String getStatus() {
		return status;
	}
	public void setStatus(String status) {
		this.status = status;
	}
	
	@OneToMany(fetch = FetchType.LAZY, mappedBy = "tFileAttach")
	public List<TAbatchErreLog> gettAbatchErreLogs() {
		return tAbatchErreLogs;
	}
	public void settAbatchErreLogs(List<TAbatchErreLog> tAbatchErreLogs) {
		this.tAbatchErreLogs = tAbatchErreLogs;
	}
	
	public void copyFile(FileParameter file)
			throws Exception {
		if(file == null)
			return;
			
		if (file.m_lSize < 0) {
			throw new Exception("文件最大大小为10M");
		}
		// 输入文件
		File contrFile = new File(file.m_strFullPath);

		if (contrFile.exists()) {
			byte[] bytes = new byte[(int) file.m_lSize];
			int offset = 0;
			int numRead = 0;
			InputStream is = new FileInputStream(contrFile);
			try {
				while (offset < bytes.length
						&& (numRead = is.read(bytes, offset, bytes.length
								- offset)) >= 0) {
					offset += numRead;
				}
				if (offset < bytes.length) {
					throw new IOException("Could not completely read file "
							+ file.getFileName());
				}
			} catch (Exception e) {
				throw new Exception(e);
			} finally {
				is.close();
			}
			
			this.setFileData(BlobFieldUtil.bytesToBlob(bytes));
			this.setFileSize(file.m_lSize);
			this.setFileName(file.m_strFileName);
			this.setContentType(file.m_strContentType);
		}
	}
	
	
	@Transient
	public boolean isDelete() {
		return delete;
	}
	public void setDelete(boolean delete) {
		this.delete = delete;
	}
}
